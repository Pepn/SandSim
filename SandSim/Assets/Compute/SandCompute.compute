#pragma kernel CSMain

static const int numThreads = 4;
static const float4 empty = float4(0.0f, 0.0f, 0.0f, 0.0f);

int Resolution;
int step;
RWTexture2D<float4> Result;
RWStructuredBuffer<int> spawnSandBuffer;

bool IsFirstStep(uint step)
{
    return step == 0;
}

bool IsSecondStep(uint step)
{
    return step == 1;
}

bool IsThirdStep(uint step)
{
    return step == 2;
}

bool IsVexelEven(uint y)
{
    return (y % 2) == 0;
}

bool IsVexelUneven(uint y)
{
    return (y % 2) != 0;
}

// Function to generate a random float between 0 and 1
float RandomFloat(float2 seed)
{
    return frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453);
}

bool DropSandPixelLeft(int idx, int idy)
{
    // Generate a random seed based on thread ID
    float2 seed = float2(idx, idy);

    // Generate a random float between 0 and 1
    float randomValue = RandomFloat(seed);

    // Use the random value to determine the outcome (50/50 chance)
    return randomValue < 0.5f;
}


[numthreads(numThreads, numThreads, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{    
    // Calculate the 1D index based on the 2D coordinates
    int index = id.y * Resolution + id.x;
    
    Result[id.xy] = Result[id.xy] + float4(spawnSandBuffer[index], 0.0f, 0.0f, 0.0);
    
    int width = Resolution;
    int height = Resolution;
    
    // Loop over the texture from bottom to top
    int y = id.y;
    
    if (y >= height-1)
    {
        return;
    }
    
    int2 centerCoord = int2(id.x, y);
    int2 belowCoord = centerCoord + int2(0, 1); // Below
    int2 belowLeftCoord = centerCoord + int2(-1, 1); // Below
    int2 leftCoord = centerCoord + int2(-1, 0); // Left
    int2 rightCoord = centerCoord + int2(1, 0); // Right
    int2 belowRightCoord = centerCoord + int2(1, 1); // Right
    int2 upCoord = centerCoord + int2(0, -1); // Up
    
    // start sand rules
    
    // sand falling down split per alternating row so we dont overwrite
    if (IsVexelUneven(id.y) && IsFirstStep(step))
    {
        if (Result[centerCoord].r != empty.r && Result[belowCoord].r == empty.r)
        {
            Result[belowCoord] = Result[centerCoord];
            Result[centerCoord] = empty;
        }
    }
    else if (IsVexelEven(id.y) & IsSecondStep(step))
    {
        //float4 debug = float4(0, IsVexelUneven(id.y) & IsFrameIdEven(frameId) ? 1.0f : 0.0f, 0, 0);
        //Result[centerCoord] = debug;
        if (Result[centerCoord].r != empty.r && Result[belowCoord].r == empty.r)
        {
            Result[belowCoord] = Result[centerCoord];
            Result[centerCoord] = empty;
        }
    }
    
    // sand falling left and right split per alternating row so we dont overwrite
    if (IsThirdStep(step))
    {
        if (Result[centerCoord].r != empty.r)
        {
            // if below is empty put this vexel there
            if (Result[belowCoord].r != empty.r)
            {
                if (belowLeftCoord.x > 1 && Result[belowLeftCoord].r == empty.r && DropSandPixelLeft(id.x, id.y))
                {
                    Result[belowLeftCoord] = Result[centerCoord];
                    Result[centerCoord] = empty;
                }
                else if (belowRightCoord.x < Resolution -1 && Result[belowRightCoord].r == empty.r)
                {
                    Result[belowRightCoord] = Result[centerCoord];
                    Result[centerCoord] = empty;
                }
            }
        }
    }
}
