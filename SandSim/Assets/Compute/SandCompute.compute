#pragma kernel CSMain

static const int numThreads = 4;
static const float4 empty = float4(0.0f, 0.0f, 0.0f, 0.0f);
static const float4 sand = float4(0.880, 0.851, 0.299, 0.0f);

int Resolution;
int step;
RWTexture2D<float4> Result;
RWStructuredBuffer<int> spawnSandBuffer;

bool IsFirstStep(uint step)
{
    return step == 0;
}

bool IsSecondStep(uint step)
{
    return step == 1;
}

void Swap(inout float4 a, inout float4 b)
{
    float4 tmp = a;
    a = b;
    b = tmp;
}

[numthreads(numThreads, numThreads, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{    
    // Calculate the 1D index based on the 2D coordinates
    int index = id.y * Resolution + id.x;
    
    if (spawnSandBuffer[index] == 1 && Result[id.xy].r == 0)
    {
        Result[id.xy] = Result[id.xy] + sand;
    }
    
    // Calculate the top-left corner of the current 2x2 block
    int2 blockStart = int2(id.xy * 2);
    
    // On alternating frames offset the block 
    //https://en.wikipedia.org/wiki/Block_cellular_automaton
    if (IsFirstStep(step))
    {
        blockStart += int2(-1, -1);
    }

    int2 pTopLeft = blockStart;
    int2 pTopRight = blockStart + int2(1, 0);
    int2 pBottomLeft = blockStart + int2(0, 1);
    int2 pBottomRight = blockStart + int2(1, 1);
    
    // hard stop at bottom
    if (pBottomLeft.y >= Resolution)
    {
        return;
    }
    
    if (Result[pTopLeft].r != empty.r && Result[pBottomLeft].r == empty.r)
    {
        Swap(Result[pTopLeft], Result[pBottomLeft]);
    }
    
    if (Result[pTopRight].r != empty.r && Result[pBottomRight].r == empty.r)
    {
        Swap(Result[pTopRight], Result[pBottomRight]);
    }
    
    if (Result[pTopLeft].r != empty.r && Result[pBottomLeft].r != empty.r && Result[pBottomRight].r == empty.r && pBottomRight.x < Resolution )
    {
        Swap(Result[pTopLeft], Result[pBottomRight]);
    }
    
    if (Result[pTopRight].r != empty.r && Result[pBottomRight].r != empty.r && Result[pBottomLeft].r == empty.r && pBottomLeft.x >= 0)
    {
        Swap(Result[pTopRight], Result[pBottomLeft]);
    }
}
