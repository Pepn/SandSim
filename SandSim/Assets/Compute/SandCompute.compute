#pragma kernel CSMain

static const int numThreads = 4;

#define EMPTY 0.0f     // Represents normal pixel
#define DELETE -1.0f     // Represents normal pixel
#define SAND 1.0f      // Represents sand pixel
#define STONE 0.9f      // Represents sand pixel

static const float4 empty = float4(0.0f, 0.0f, 0.0f, 0.0f);
static const float4 sand = float4(0.880, 0.801, 0.299, SAND);
static const float4 stone = float4(0.880, 0.851, 0.890, STONE);

int Resolution;
int step;
RWTexture2D<float4> Result;
RWStructuredBuffer<float> spawnSandBuffer;

// to alternate the blocks
bool IsFirstStep(uint step)
{
    return step == 0;
}

void Swap(inout float4 a, inout float4 b)
{
    float4 tmp = a;
    a = b;
    b = tmp;
}

// Hash function to create pseudo-random-like values
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// Function to add a random color offset to a pixel
float4 AddRandomColorOffset(float4 color, float offsetRange, float2 pixelCoord)
{
    float randomOffset = Hash(pixelCoord); // Generate a random value based on pixel coordinates
    randomOffset = (randomOffset * 2.0 - 1.0) * offsetRange; // Scale and center the random value within the offset range
    return float4((color + randomOffset).rgb, color.a);; // Add the random offset to each color channel
}

[numthreads(numThreads, numThreads, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{    
    // Calculate the 1D index based on the 2D coordinates
    int index = id.y * Resolution + id.x;
    
    // read the input buffer and spawn pixel types
    if (spawnSandBuffer[index] == SAND && Result[id.xy].a == EMPTY)
    {
        Result[id.xy] = AddRandomColorOffset(sand, 0.1f, id.xy);
    }
    
    if (spawnSandBuffer[index] == DELETE && Result[id.xy].a != EMPTY)
    {
        Result[id.xy] = empty;
    }
    
    if (spawnSandBuffer[index] == STONE)
    {
        Result[id.xy] = AddRandomColorOffset(stone, 0.2f, id.xy);
    }
    
    // Calculate the top-left corner of the current 2x2 block
    int2 blockStart = int2(id.xy * 2);
    
    // On alternating frames offset the block 
    //https://en.wikipedia.org/wiki/Block_cellular_automaton
    if (IsFirstStep(step))
    {
        blockStart += int2(-1, -1);
    }

    int2 pTopLeft = blockStart;
    int2 pTopRight = blockStart + int2(1, 0);
    int2 pBottomLeft = blockStart + int2(0, 1);
    int2 pBottomRight = blockStart + int2(1, 1);
    
    // hard stop at bottom
    if (pBottomLeft.y >= Resolution)
    {
        return;
    }
    
    if (Result[pTopLeft].a == SAND && Result[pBottomLeft].a == EMPTY)
    {
        Swap(Result[pTopLeft], Result[pBottomLeft]);
    }
    
    if (Result[pTopRight].a == SAND && Result[pBottomRight].a == EMPTY)
    {
        Swap(Result[pTopRight], Result[pBottomRight]);
    }
    
    if (Result[pTopLeft].a == SAND && Result[pBottomLeft].a != EMPTY && Result[pBottomRight].r == EMPTY && pBottomRight.x < Resolution)
    {
        Swap(Result[pTopLeft], Result[pBottomRight]);
    }
    
    if (Result[pTopRight].a == SAND && Result[pBottomRight].a != EMPTY && Result[pBottomLeft].a == EMPTY && pBottomLeft.x >= 0)
    {
        Swap(Result[pTopRight], Result[pBottomLeft]);
    }
}
