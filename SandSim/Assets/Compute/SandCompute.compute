#pragma kernel CSMain

static const int numThreads = 4;

#define EMPTY 0.0f     // Represents normal pixel
#define DELETE -1.0f     // Represents normal pixel
#define SAND 1.0f      // Represents sand pixel
#define STONE 0.9f      // Represents sand pixel

static const float4 empty = float4(0.0f, 0.0f, 0.0f, 0.0f);
static const float4 sand = float4(0.880, 0.851, 0.299, SAND);
static const float4 stone = float4(0.880, 0.851, 0.890, STONE);

int Resolution;
int step;
RWTexture2D<float4> Result;
RWStructuredBuffer<float> spawnSandBuffer;

// to alternate the blocks
bool IsFirstStep(uint step)
{
    return step == 0;
}

void Swap(inout float4 a, inout float4 b)
{
    float4 tmp = a;
    a = b;
    b = tmp;
}

[numthreads(numThreads, numThreads, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{    
    // Calculate the 1D index based on the 2D coordinates
    int index = id.y * Resolution + id.x;
    
    // read the input buffer and spawn pixel types
    if (spawnSandBuffer[index] == SAND && Result[id.xy].a == EMPTY)
    {
        Result[id.xy] = Result[id.xy] + sand;
    }
    
    if (spawnSandBuffer[index] == DELETE && Result[id.xy].a != EMPTY)
    {
        Result[id.xy] = empty;
    }
    
    if (spawnSandBuffer[index] == STONE)
    {
        Result[id.xy] = stone;
    }
    
    // Calculate the top-left corner of the current 2x2 block
    int2 blockStart = int2(id.xy * 2);
    
    // On alternating frames offset the block 
    //https://en.wikipedia.org/wiki/Block_cellular_automaton
    if (IsFirstStep(step))
    {
        blockStart += int2(-1, -1);
    }

    int2 pTopLeft = blockStart;
    int2 pTopRight = blockStart + int2(1, 0);
    int2 pBottomLeft = blockStart + int2(0, 1);
    int2 pBottomRight = blockStart + int2(1, 1);
    
    // hard stop at bottom
    if (pBottomLeft.y >= Resolution)
    {
        return;
    }
    
    if (Result[pTopLeft].a == SAND && Result[pBottomLeft].a == EMPTY)
    {
        Swap(Result[pTopLeft], Result[pBottomLeft]);
    }
    
    if (Result[pTopRight].a == SAND && Result[pBottomRight].a == EMPTY)
    {
        Swap(Result[pTopRight], Result[pBottomRight]);
    }
    
    if (Result[pTopLeft].a == SAND && Result[pBottomLeft].a != EMPTY && Result[pBottomRight].r == EMPTY && pBottomRight.x < Resolution)
    {
        Swap(Result[pTopLeft], Result[pBottomRight]);
    }
    
    if (Result[pTopRight].a == SAND && Result[pBottomRight].a != EMPTY && Result[pBottomLeft].a == EMPTY && pBottomLeft.x >= 0)
    {
        Swap(Result[pTopRight], Result[pBottomLeft]);
    }
}
